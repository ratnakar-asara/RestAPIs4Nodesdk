# PHONY targets have no dependencies and they will be built unconditionally.
.PHONY: all-generated-artifacts rm-generated-artifacts up up-detached logs-follow down down-full rm-state-volumes rm-node-modules rm-chaincode-docker-resources

all-generated-artifacts: generated-artifacts/crypto-config generated-artifacts/mychannel.tx generated-artifacts/orderer.genesis.block

rm-generated-artifacts:
	rm generated-artifacts -rf

generated-artifacts/crypto-config: source-artifacts/crypto-config.yaml
	mkdir -p generated-artifacts
	$(GOPATH)/src/github.com/hyperledger/fabric/build/bin/cryptogen generate --output=generated-artifacts/crypto-config --config=source-artifacts/crypto-config.yaml
	# These dirs should be but aren't generated by cryptogen
	mkdir -p generated-artifacts/crypto-config/ordererOrganizations/example.com/msp/intermediatecerts
	mkdir -p generated-artifacts/crypto-config/ordererOrganizations/example.com/msp/crls
	mkdir -p generated-artifacts/crypto-config/peerOrganizations/org0.example.com/msp/intermediatecerts
	mkdir -p generated-artifacts/crypto-config/peerOrganizations/org0.example.com/msp/crls
	mkdir -p generated-artifacts/crypto-config/peerOrganizations/org1.example.com/msp/intermediatecerts
	mkdir -p generated-artifacts/crypto-config/peerOrganizations/org1.example.com/msp/crls

generated-artifacts/mychannel.tx: source-artifacts/configtx.yaml generated-artifacts/crypto-config
	mkdir -p generated-artifacts
	cd source-artifacts && $(GOPATH)/src/github.com/hyperledger/fabric/build/bin/configtxgen -profile TwoOrgsChannel -outputCreateChannelTx ../generated-artifacts/mychannel.tx -channelID mychannel

generated-artifacts/orderer.genesis.block: source-artifacts/configtx.yaml generated-artifacts/crypto-config
	mkdir -p generated-artifacts
	cd source-artifacts && $(GOPATH)/src/github.com/hyperledger/fabric/build/bin/configtxgen -profile TwoOrgsOrdererGenesis -outputBlock ../generated-artifacts/orderer.genesis.block

# Bring up all services (and necessary volumes, networks, etc)
up: all-generated-artifacts
	docker-compose up --abort-on-container-exit

# Bring up all services (and necessary volumes, networks, etc) in detached mode
up-detached: all-generated-artifacts
	docker-compose up -d --abort-on-container-exit

# Follow the output of the logs
logs-follow:
	docker-compose logs --follow --tail="all"

# Bring down all services (delete associated containers, networks, but not volumes)
down:
	docker-compose down

# Bring down all services and volumes (delete associated containers, networks, AND volumes)
down-full:
	docker-compose down -v

# Delete the "state" volumes -- tmp dir (which contains the webserver's key store) and HFC key/value store in home dir
# This can be done after `make down` to reset things to a "clean state", without needing to recompile go code or
# run `npm install` from scratch.
rm-state-volumes:
	docker volume rm fabricsamplewebapp_webserver_tmp fabricsamplewebapp_webserver_homedir

# Delete the node_modules dir, in case things get inexplicably screwy and you just feel like you have to nuke something.
rm-node-modules:
	docker volume rm fabricsamplewebapp_webserver_homedir_node_modules

# Delete the containers and images created by the peers that run chaincode.  This will be necessary if the chaincode
# is changed, because new docker images will have to be built with the new chaincode.  If the chaincode has not changed,
# then this is not necessary.  The semicolons are to run the commands sequentially without heeding the exit code.  The
# command `true` is called last so that the make rule is always considered to have succeeded.
rm-chaincode-docker-resources:
	docker rm dev-peer0.org0.example.com-mycc-v0 \
	          dev-peer1.org0.example.com-mycc-v0 \
	          dev-peer0.org1.example.com-mycc-v0 \
	          dev-peer1.org1.example.com-mycc-v0; \
	docker rmi dev-peer0.org0.example.com-mycc-v0 \
	           dev-peer1.org0.example.com-mycc-v0 \
	           dev-peer0.org1.example.com-mycc-v0 \
	           dev-peer1.org1.example.com-mycc-v0; \
	true
